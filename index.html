<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Topo to STL — シンプル3D地形メーカー</title>
  <style>
    /* 簡易スタイル（読みやすさ優先） */
    :root{--accent:#5b21b6;--muted:#6b7280}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; margin:0; background:#f8fafc; color:#0f172a}
    .wrap{max-width:1200px;margin:20px auto;padding:16px;display:grid;grid-template-columns:360px 1fr;gap:18px}
    .card{background:#fff;border-radius:12px;padding:14px;border:1px solid #e6edf3;box-shadow:0 1px 4px rgba(12,15,20,0.02)}
    h1{margin:0 0 10px;font-size:18px}
    label,button{font-size:14px}
    input[type="range"]{width:100%}
    .btn{display:inline-block;padding:10px 14px;border-radius:8px;background:var(--accent);color:#fff;border:none;cursor:pointer}
    .btn.secondary{background:#10b981}
    .muted{color:var(--muted);font-size:13px}
    .controls .row{margin-bottom:12px}
    #mount{width:100%;height:75vh;border-radius:10px;background:#fff;border:1px solid #e6edf3;overflow:hidden}
    .footer{margin-top:14px;color:var(--muted);font-size:13px}
    .error{color:#b91c1c;background:#fff1f2;padding:8px;border-radius:6px;border:1px solid #fecaca}
    .busy{color:#92400e;background:#fff7ed;padding:8px;border-radius:6px;border:1px solid #fcd34d}
    .label{font-weight:600;margin-bottom:6px;display:block}
    .small{font-size:13px;color:#374151}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card controls">
      <h1>Topo to STL — シンプル3D地形メーカー</h1>

      <div class="row">
        <div class="label">1) NetCDFファイルを選択（.nc）</div>
        <input id="fileinput" type="file" accept=".nc,application/x-netcdf,application/netcdf">
        <div class="muted small">NetCDF4 (CF 準拠) を推奨。アップロード後に解析して3D表示します。</div>
      </div>

      <div class="row">
        <div class="label">2) 可視化の調整</div>
        <div class="small">縦方向の誇張: <span id="exaggLabel">1.00×</span></div>
        <input id="exagg" type="range" min="0.1" max="20" step="0.1" value="1">
        <div style="margin-top:6px"><input id="exaggNum" type="number" min="0.1" max="20" step="0.1" value="1" style="width:90px;padding:6px;border-radius:6px;border:1px solid #e6edf3"></div>
        <div style="margin-top:10px" class="small">
          台座の厚み（m）: <input id="baseThickness" type="number" value="20" style="width:80px;padding:6px;border-radius:6px;border:1px solid #e6edf3">
        </div>
        <div style="margin-top:10px" class="small">間引き（行/列の最大）: <input id="maxDim" type="range" min="200" max="1200" step="50" value="900"></div>
      </div>

      <div class="row">
        <div class="label">3) 出力設定</div>
        <select id="unit">
          <option value="mm">mm（3Dプリンタ向け既定）</option>
          <option value="m">m</option>
        </select>
      </div>

      <div class="row" style="display:flex;gap:10px;">
        <button id="exportBtn" class="btn" disabled>STLをダウンロード</button>
        <button id="testBtn" class="btn secondary">h5wasm 接続テスト</button>
      </div>

      <div id="status" style="margin-top:10px"></div>

      <div style="margin-top:10px" class="footer small">
        ※ このページはビルド不要の自己完結HTMLです。Three.js と h5wasm を CDN から読み込みます。  
        ※ STL は単位情報を持ちません。一般的には mm として扱われます。
      </div>
    </div>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center;padding-bottom:8px;border-bottom:1px solid #f1f5f9;margin-bottom:8px">
        <div style="font-weight:600">3D プレビュー</div>
        <div class="muted small">Z-up / 回転: ドラッグ / ズーム: ホイール</div>
      </div>
      <div id="mount"></div>
    </div>
  </div>

  <script type="module">
    // ---- モジュールを直接CDNから import ----
    import * as THREE from 'https://unpkg.com/three@0.155.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.155.0/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://unpkg.com/three@0.155.0/examples/jsm/exporters/STLExporter.js';

    // ---- DOM ----
    const fileInput = document.getElementById('fileinput');
    const exagg = document.getElementById('exagg');
    const exaggNum = document.getElementById('exaggNum');
    const exaggLabel = document.getElementById('exaggLabel');
    const baseThicknessInput = document.getElementById('baseThickness');
    const maxDimInput = document.getElementById('maxDim');
    const unitSelect = document.getElementById('unit');
    const exportBtn = document.getElementById('exportBtn');
    const testBtn = document.getElementById('testBtn');
    const statusDiv = document.getElementById('status');
    const mount = document.getElementById('mount');

    // ---- state ----
    let grid = null; // { lats, lons, Z, shape: [R,C] }
    let mesh = null;
    let renderer, scene, camera, controls;
    let currentFileName = 'terrain';
    let h5Module = null;

    // ---- helper UI funcs ----
    function setStatusHTML(html) { statusDiv.innerHTML = html; }
    function setBusy(msg) { setStatusHTML('<div class="busy">'+msg+'</div>'); }
    function setError(msg) { setStatusHTML('<div class="error">'+msg+'</div>'); }
    function clearStatus() { setStatusHTML(''); }

    // ---- init three.js ----
    function initThree() {
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      renderer.setSize(mount.clientWidth, mount.clientHeight);
      mount.appendChild(renderer.domElement);

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf7fafc);

      camera = new THREE.PerspectiveCamera(45, mount.clientWidth / mount.clientHeight, 0.1, 1e9);
      camera.position.set(0, -2000, 1500);
      camera.up.set(0,0,1);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      scene.add(new THREE.HemisphereLight(0xffffff, 0x888888, 0.8));
      const dl = new THREE.DirectionalLight(0xffffff, 0.8);
      dl.position.set(1000, -1000, 2000);
      scene.add(dl);

      window.addEventListener('resize', () => {
        if (!mount) return;
        camera.aspect = mount.clientWidth / mount.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(mount.clientWidth, mount.clientHeight);
      });

      (function animate(){
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      })();
    }

    initThree();

    // ---- h5wasm: fetch->blob->import で確実に取得するユーティリティ ----
    async function importModuleFromUrlAsBlob(url) {
      const base = url.slice(0, url.lastIndexOf('/') + 1);
      // Ensure Emscripten locateFile is set so .wasm is found relative to base
      window.Module = window.Module || {};
      window.Module.locateFile = (path) => {
        if (/^https?:\\/\\//.test(path)) return path;
        return base + path;
      };

      const r = await fetch(url);
      if (!r.ok) throw new Error('fetch failed: '+r.status);
      const code = await r.text();
      const blob = new Blob([code], { type: 'text/javascript' });
      const blobUrl = URL.createObjectURL(blob);
      try {
        const mod = await import(/* @vite-ignore */ blobUrl);
        return mod.default || mod;
      } finally {
        // delay revoke a bit
        setTimeout(()=>{ try{ URL.revokeObjectURL(blobUrl);}catch(e){} },1500);
      }
    }

    async function importH5Wasm() {
      if (h5Module) return h5Module;
      const cdns = [
        'https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5_hl.js',
        'https://unpkg.com/h5wasm@0.4.9/dist/esm/hdf5_hl.js'
      ];
      let lastErr = null;
      for (const u of cdns) {
        try {
          const m = await importModuleFromUrlAsBlob(u);
          if (m && m.ready) {
            try { await m.ready; } catch(e){}
          }
          h5Module = m;
          return m;
        } catch (e) {
          console.warn('h5 wasm import failed for', u, e);
          lastErr = e;
        }
      }
      throw lastErr || new Error('h5wasm import failed');
    }

    // ---- NetCDF (.nc) 読み込みとパース ----
    async function loadNetCDFFile(file) {
      clearStatus();
      setBusy('NetCDF を解析中...');
      try {
        currentFileName = (file && file.name) ? file.name.replace(/\\.[^.]+$/, '') : 'terrain';
        const h5 = await importH5Wasm();
        if (h5 && h5.ready) {
          try { await h5.ready; } catch (e){}
        }

        const ab = await file.arrayBuffer();
        // write to h5wasm FS
        try {
          h5.FS.writeFile(file.name, new Uint8Array(ab));
        } catch (fsErr) {
          throw new Error('FS.writeFile failed: '+(fsErr && fsErr.message ? fsErr.message : String(fsErr)));
        }

        const f = new h5.File(file.name, 'r');
        try {
          const rootKeys = f.keys ? f.keys() : [];
          const elevCandidates = ['elevation','z','bathymetry','bedrock'];
          const latCandidates = ['lat','latitude','y'];
          const lonCandidates = ['lon','longitude','x'];

          const findFirst = (cands) => {
            return rootKeys.find(k => cands.some(c => k.toLowerCase().includes(c))) || null;
          };

          let elevKey = findFirst(elevCandidates);
          let latKey = findFirst(latCandidates);
          let lonKey = findFirst(lonCandidates);

          // deep search if any missing
          const searchDeep = (groupPath='') => {
            const grp = groupPath ? f.get(groupPath) : f;
            const keys = grp.keys ? grp.keys() : [];
            for (const k of keys) {
              const full = groupPath ? (groupPath + '/' + k) : k;
              const obj = grp.get ? grp.get(k) : null;
              if (!obj) continue;
              const isDataset = !!obj.value || !!obj.metadata;
              if (isDataset) {
                if (!elevKey && elevCandidates.some(c=>k.toLowerCase().includes(c))) elevKey = full;
                if (!latKey && latCandidates.some(c=>k.toLowerCase().includes(c))) latKey = full;
                if (!lonKey && lonCandidates.some(c=>k.toLowerCase().includes(c))) lonKey = full;
              } else {
                searchDeep(full);
              }
            }
          };

          if (!elevKey || !latKey || !lonKey) searchDeep('');
          if (!elevKey || !latKey || !lonKey) {
            throw new Error('必要な変数が見つかりません。ファイル内のキー: ' + rootKeys.join(', '));
          }

          const Zds = f.get(elevKey);
          const latds = f.get(latKey);
          const londs = f.get(lonKey);

          const shape = Zds.shape || [0,0];
          if (!shape || shape.length !== 2) throw new Error('標高データが2次元ではありません');

          const rows0 = shape[0], cols0 = shape[1];
          if (rows0 * cols0 > 150_000_000) throw new Error('グリッドが大きすぎます。領域を絞ってください。');

          const Zraw = Zds.value;
          const lats = latds.value;
          const lons = londs.value;

          grid = { lats, lons, Z: Zraw, shape: [rows0, cols0] };

          // quick stats
          let minV = Infinity, maxV = -Infinity;
          for (let i=0;i<Zraw.length;i+=Math.max(1,Math.floor(Zraw.length/500000))) {
            const v = Number(Zraw[i]);
            if (v < minV) minV = v;
            if (v > maxV) maxV = v;
          }

          clearStatus();
          setBusy('メッシュを生成中…');
          await buildOrUpdateMesh();
        } finally {
          try { f.close && f.close(); } catch(e){}
        }
      } catch (e) {
        console.error(e);
        setError(e.message || String(e));
      } finally {
        setBusy('');
      }
    }

    // ---- ジオメトリ生成ロジック（元の TS を JS 化） ----
    function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
    function viridis(t){
      const a=[0.280268,0.165368,0.476043];
      const b=[0.23393,0.472705,0.310964];
      const c=[0.043831,0.530361,0.393395];
      const d=[2.0,1.5,1.0];
      const e=[0.0,0.5,1.0];
      const r=a[0]+b[0]*Math.pow(t,d[0])+c[0]*Math.pow(t,e[0]);
      const g=a[1]+b[1]*Math.pow(t,d[1])+c[1]*Math.pow(t,e[1]);
      const bl=a[2]+b[2]*Math.pow(t,d[2])+c[2]*Math.pow(t,e[2]);
      return [Math.min(1,Math.max(0,r)),Math.min(1,Math.max(0,g)),Math.min(1,Math.max(0,bl))];
    }

    const MAX_DIM = 1200;
    const MAX_VERTICES = 1500000;

    function calcSteps(R,C,maxDim){
      const stepY0 = Math.max(1, Math.ceil(R / maxDim));
      const stepX0 = Math.max(1, Math.ceil(C / maxDim));
      const estRows = Math.ceil(R / stepY0);
      const estCols = Math.ceil(C / stepX0);
      let factor=1;
      while (estRows * estCols * 2 > MAX_VERTICES) {
        factor++;
        if (factor>20) break;
      }
      return { stepY: stepY0*factor, stepX: stepX0*factor };
    }

    function buildSolidGeometry(lats,lons,Z,shape,exag,base,maxDim){
      const R = shape[0], C = shape[1];
      const {stepY, stepX} = calcSteps(R,C, clamp(maxDim,100,MAX_DIM));
      const rows1 = Math.ceil(R/stepY), cols1 = Math.ceil(C/stepX);

      const avgLatDeg = (lats[0] + lats[lats.length-1]) / 2;
      const avgLatRad = (avgLatDeg * Math.PI)/180;
      const mPerDegLat = 111320;
      const mPerDegLon = 111320 * Math.cos(avgLatRad);

      const rowsIdx = new Int32Array(rows1);
      const colsIdx = new Int32Array(cols1);
      for (let i=0,v=0;i<rows1;i++,v+=stepY) rowsIdx[i] = Math.min(v,R-1);
      for (let j=0,v=0;j<cols1;j++,v+=stepX) colsIdx[j] = Math.min(v,C-1);

      const lat0 = lats[rowsIdx[0]];
      const lon0 = lons[colsIdx[0]];

      const getZ = (i,j) => Number(Z[i*C + j]) * exag;

      let zMinSurface = Infinity, zMaxSurface = -Infinity;
      for (let ii=0;ii<rows1;ii++){
        const i0 = rowsIdx[ii];
        for (let jj=0;jj<cols1;jj++){
          const j0 = colsIdx[jj];
          const z = getZ(i0,j0);
          if (z<zMinSurface) zMinSurface = z;
          if (z>zMaxSurface) zMaxSurface = z;
        }
      }

      const bottomZ = zMinSurface - Math.abs(base);

      const topVerts = rows1 * cols1;
      const totalVerts = topVerts * 2;

      const positions = new Float32Array(totalVerts * 3);
      const colors = new Float32Array(totalVerts * 3);
      let p=0,ci=0;

      for (let ii=0;ii<rows1;ii++){
        const i0 = rowsIdx[ii];
        const y = (lats[i0] - lat0) * mPerDegLat;
        for (let jj=0;jj<cols1;jj++){
          const j0 = colsIdx[jj];
          const x = (lons[j0] - lon0) * mPerDegLon;
          const z = getZ(i0,j0);
          positions[p++] = x; positions[p++] = y; positions[p++] = z;
          colors[ci++] = 0; colors[ci++] = 0; colors[ci++] = 0;
        }
      }

      for (let ii=0;ii<rows1;ii++){
        for (let jj=0;jj<cols1;jj++){
          const idxTop = ii*cols1 + jj;
          const baseIdx = idxTop*3;
          positions[p++] = positions[baseIdx + 0];
          positions[p++] = positions[baseIdx + 1];
          positions[p++] = bottomZ;
          colors[ci++] = 0.2; colors[ci++] = 0.2; colors[ci++] = 0.2;
        }
      }

      const dz = Math.max(1e-6, zMaxSurface - zMinSurface);
      for (let ii=0;ii<rows1;ii++){
        for (let jj=0;jj<cols1;jj++){
          const idxTop = ii*cols1 + jj;
          const z = positions[idxTop*3 + 2];
          const t = clamp((z - zMinSurface) / dz, 0, 1);
          const [r,g,b] = viridis(t);
          const ci2 = idxTop*3;
          colors[ci2] = r; colors[ci2+1] = g; colors[ci2+2] = b;
        }
      }

      const faces = [];
      const top = (r,c) => r*cols1 + c;
      const bottom = (r,c) => topVerts + r*cols1 + c;

      for (let i=0;i<rows1-1;i++){
        for (let j=0;j<cols1-1;j++){
          const v0 = top(i,j), v1 = top(i,j+1), v2 = top(i+1,j), v3 = top(i+1,j+1);
          faces.push(v0, v1, v3, v0, v3, v2);
        }
      }

      // sides
      for (let j=0;j<cols1-1;j++){
        const a=top(0,j), b=top(0,j+1), A=bottom(0,j), B=bottom(0,j+1);
        faces.push(a,A,B, a,B,b);
      }
      for (let j=0;j<cols1-1;j++){
        const a=top(rows1-1,j), b=top(rows1-1,j+1), A=bottom(rows1-1,j), B=bottom(rows1-1,j+1);
        faces.push(a,b,B, a,B,A);
      }
      for (let i=0;i<rows1-1;i++){
        const a=top(i,0), b=top(i+1,0), A=bottom(i,0), B=bottom(i+1,0);
        faces.push(a,A,B, a,B,b);
      }
      for (let i=0;i<rows1-1;i++){
        const a=top(i,cols1-1), b=top(i+1,cols1-1), A=bottom(i,cols1-1), B=bottom(i+1,cols1-1);
        faces.push(a,b,B, a,B,A);
      }

      // bottom
      for (let i=0;i<rows1-1;i++){
        for (let j=0;j<cols1-1;j++){
          const v0 = bottom(i,j), v1 = bottom(i,j+1), v2 = bottom(i+1,j), v3 = bottom(i+1,j+1);
          faces.push(v0, v3, v1, v0, v2, v3);
        }
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geom.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      geom.setIndex(faces);
      geom.computeVertexNormals();
      geom.computeBoundingBox();
      const bb = geom.boundingBox;
      const size = new THREE.Vector3();
      bb.getSize(size);

      return { geom, rows1, cols1, size, bottomZ };
    }

    // ---- メッシュ生成/更新 ----
    async function buildOrUpdateMesh() {
      if (!grid) return;
      setBusy('メッシュを生成中…');
      await new Promise(r=>setTimeout(r,10));
      const exagVal = Number(exagg.value) || 1;
      const base = Number(baseThicknessInput.value) || 20;
      const maxDim = Number(maxDimInput.value) || 900;
      const res = buildSolidGeometry(grid.lats, grid.lons, grid.Z, grid.shape, exagVal, base, maxDim);
      if (mesh) {
        scene.remove(mesh);
        mesh.geometry.dispose();
        mesh.material.dispose();
        mesh = null;
      }
      const mat = new THREE.MeshStandardMaterial({ vertexColors:true, metalness:0.1, roughness:0.8, side:THREE.DoubleSide });
      mesh = new THREE.Mesh(res.geom, mat);
      scene.add(mesh);

      // camera framing
      const bb = res.geom.boundingBox;
      const size = new THREE.Vector3(); bb.getSize(size);
      const diag = Math.max(size.x, size.y, size.z);
      const dist = diag * 1.6 + 1;
      camera.position.set(-dist*0.6, -dist*0.6, dist*0.6);
      controls.target.set(size.x*0.5, size.y*0.5, size.z*0.2);
      controls.update();

      exportBtn.disabled = false;
      clearStatus();
    }

    // ---- STL export ----
    function exportSTL() {
      if (!mesh) return;
      const scale = (unitSelect.value === 'mm') ? 1000 : 1;
      // scale positions
      const g = mesh.geometry;
      const posAttr = g.getAttribute('position');
      const arr = new Float32Array(posAttr.count * 3);
      for (let i=0;i<posAttr.count;i++){
        arr[i*3 + 0] = posAttr.getX(i) * scale;
        arr[i*3 + 1] = posAttr.getY(i) * scale;
        arr[i*3 + 2] = posAttr.getZ(i) * scale;
      }
      const g2 = new THREE.BufferGeometry();
      g2.setAttribute('position', new THREE.BufferAttribute(arr, 3));
      const idx = g.getIndex();
      if (idx) g2.setIndex(idx.array);
      g2.computeVertexNormals();
      const m2 = new THREE.MeshStandardMaterial({ side: THREE.DoubleSide });
      const mesh2 = new THREE.Mesh(g2, m2);

      const exporter = new STLExporter();
      const binary = exporter.parse(mesh2, { binary: true });
      const blob = new Blob([binary], { type: 'application/octet-stream' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = currentFileName + '_solid_' + unitSelect.value + '.stl';
      a.click();
      setTimeout(()=>{ URL.revokeObjectURL(a.href); },1500);
    }

    // ---- UI イベント ----
    fileInput.addEventListener('change', (ev)=>{
      const f = ev.target.files && ev.target.files[0];
      if (f) {
        loadNetCDFFile(f);
      }
    });

    exagg.addEventListener('input', ()=>{ exaggNum.value = exagg.value; exaggLabel.textContent = Number(exagg.value).toFixed(2) + '×'; if (grid) buildOrUpdateMesh();});
    exaggNum.addEventListener('change', ()=>{ const v = parseFloat(exaggNum.value) || 1; exagg.value = clamp(v,0.1,20); exaggLabel.textContent = Number(exagg.value).toFixed(2) + '×'; if (grid) buildOrUpdateMesh(); });
    baseThicknessInput.addEventListener('change', ()=>{ if (grid) buildOrUpdateMesh(); });
    maxDimInput.addEventListener('input', ()=>{ if (grid) buildOrUpdateMesh(); });

    exportBtn.addEventListener('click', ()=>exportSTL());

    testBtn.addEventListener('click', async ()=>{
      setBusy('h5wasm インポートを検証中…');
      try {
        try {
          await import('h5wasm');
          setStatusHTML('<div class="small">h5wasm via bare import: OK</div>');
        } catch {
          try {
            await importModuleFromUrlAsBlob('https://cdn.jsdelivr.net/npm/h5wasm@0.4.9/dist/esm/hdf5_hl.js');
            setStatusHTML('<div class="small">h5wasm via CDN: OK</div>');
          } catch (e) {
            setError('h5wasm の取得に失敗: ' + (e && e.message ? e.message : String(e)));
          }
        }
      } finally { setBusy(''); }
    });

    // ---- ユーに優しい補助 ----
    setStatusHTML('<div class="small">ファイルを選択して解析を開始してください。右側に3Dが表示されます。</div>');

  </script>
</body>
</html>
